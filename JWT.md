
# term
- 認証
	Authentication (または AuthN)
- 認可
	Authorization (または AuthZ) 

# 署名
- **署名する**
``` plantuml
rectangle {
	file 文章 as doc{
	}
	card 署名 as sho
	
	doc -d[hidden]-> sho
}

card ハッシュ as hash
card 秘密鍵 as skey

doc -> hash
skey -left-> hash
hash -> sho
```
- **検証する**
``` plantuml
rectangle {
	file 文章 as doc{
	}
	card 署名 as sho
	
	doc -d[hidden]-> sho
}
card 計算したハッシュ as chash
card 復号したハッシュ as dhash
card 公開鍵 as pkey


doc -> chash
sho -> dhash
pkey -u-> dhash

chash <-> dhash: 比較

```

# 証明書
署名を検証する為の公開鍵が **本物** の公開鍵かどうかわからない
1. 公開鍵に認証局が署名する(認証局の秘密鍵で暗号化する)
2. 認証局の証明書はプリインストールされている(認証局の公開鍵が含まれている)
3. サーバーの公開鍵の署名を認証局の証明書で検証する
``` plantuml
rectangle キーペア as pair{
    usecase 公開鍵 as pubkey
    usecase 秘密鍵 as prikey
    file 証明書 as cert{
        usecase 公開鍵
        usecase "署名\n(キーペアの公開鍵を\n認証局の秘密鍵で暗号化)"
    }
}
rectangle 認証局 as ca{
    usecase 公開鍵 as capubkey
    usecase 秘密鍵 as caprikey
}

rectangle ユーザー as user{
    usecase "認証局の証明書\n(認証局の公開鍵が含まれる)" as cacert
    cloud "キーペアの証明書の署名を\n認証局の証明書で検証する" as proc
}
pubkey -u-> ca: 発行要求
ca -d-> cert: 発行
cert --> proc: 提示(httpsとか)
cacert -> proc
```

# Json Web Token
構成は下記となっている
1. ヘッダ
2. ペイロード
3. 署名
各項目はピリオド(.)で区切られている

#### 中身
1. ヘッダとペイロードは単なるJSONである
	必須のキー値は決められている
		ex. ハッシュのアルゴリズムとか(※)
2. ヘッダとペイロードをそれぞれBASE64でエンコードしピリオドでつなげる(①)
3.  ①を※でハッシュし秘密鍵で暗号化した結果をBASE64でエンコードする(②)
4. ①と②をピリオドでつなげる

**絶対の注意事項**
ペイロードは単なるBASE64なので機密情報を絶対に含めてはいけない

#### メリット
1. トークンのサイズが小さいのであれば、クライアントとサーバー間で非常に迅速にトークンを渡すことができます。
2. ユーザーがアクセスできるリソース、その権限の有効期間、ログオン中にユーザーが実行できる操作を指定できます。
3. セッションベースの認証ではセッションIDをサーバー側のデータベースなどで保存しておく必要があったが、トークンベースの認証であればサーバー側でトークンの情報を保存しておく必要はない。

#### デメリット
1. サイズが大きいトークンをクライアントとサーバー間で送受信すると、パフォーマンスの影響を与える可能性があります。
2. 一度発行したトークンは、サーバーで無効化する方法が基本的にはありません。
	例えば、ユーザーがログアウトしたり、権限を変更した場合でも、有効期限内のトークンは有効です。
	この回避策としては、トークンに短い有効期限を設定し、定期的に新しいトークンを発行します。
3. トークンが盗まれた場合、そのトークンを持つ者は有効期限が切れるまで正規ユーザーとして振る舞うことができます。
	この回避策としては、HTTPSを使用して通信を暗号化し、トークンの情報が読み取れないようにしておくことです。
4. クライアント側に保存したトークンがXSS攻撃によって盗まれる可能性があります。
	その回避策としては、トークンをCookieのHttpOnly属性と共に保存することで、JavaScriptからトークンの情報にアクセスできないようにしておくことです。
5. 短い有効期限のアクセストークンと、長期有効なリフレッシュトークンの組み合わせを採用すると、実装が煩雑になります。
	不正を防ぐため、リフレッシュトークンをセキュアに保存・管理する必要があります。

